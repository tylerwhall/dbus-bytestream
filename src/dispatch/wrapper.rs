//! Macros to generate method call and signal handlers from Rust impl blocks.
//!
//! These macros bind Rust functions to generic closures which can be used
//! with the message dispatcher.
//!
//! For both signals and methods, the glue code validates the arguments in
//! the message body received from the bus and will return error responses
//! to the bus without invoking the callback.
//!
//! Methods may optionally return a tuple of Encodables which will be
//! inserted in the body of the autogenerated method call response message.
//! The choice of a method to produce an autogenerated response is decided
//! at run time via an Option return. This allows method calls to
//! dynamically make the decision to defer the response message.
//!
//! Method return arguments are guaranteed to be Encodable at compile time.
//! Since the methods have a signature known at compile time, this also
//! ensures a single method will always have the same return signature.
//!
//! # Examples
//!
//! ```
//! extern crate dbus_serialize;
//! #[macro_use]
//! extern crate dbus_bytestream;
//!
//! use std::cell::Cell;
//!
//! use dbus_bytestream::connection::MessageSender;
//! use dbus_bytestream::dispatch::wrapper::HandlerError;
//! use dbus_bytestream::dispatch::wrapper::SignalReturn;
//!
//! #[derive(Default)]
//! struct MySignalHandler {
//!     val: Cell<i32>,
//! }
//!
//! dbus_signal_impl! {
//!     impl MySignalHandler {
//!         fn TheSignalName(&self, _sender: &mut MessageSender, val: i32) -> SignalReturn {
//!             self.val.set(val);
//!             Ok(())
//!         }
//!     }
//! }
//!
//! fn main() {
//!     use dbus_bytestream::connection::Connection;
//!     use dbus_bytestream::dispatch::{MessageDispatcher, MessageHandler};
//!     use dbus_bytestream::message;
//!
//!     let mut conn = Connection::connect_system().unwrap();
//!     /* Create our signal handler object */
//!     let handler: MySignalHandler = Default::default();
//!
//!
//!     /* Register the signal handlers with a dispatcher */
//!     let mut dis = MessageDispatcher::new();
//!     for (name, handler) in handler.get_signal_handlers().into_iter() {
//!         dis.add_signal("path".into(), "interface".into(), name.into(), handler);
//!     }
//!
//!     let sig = message::create_signal("path", "interface", "TheSignalName")
//!                 .add_arg(&5);
//!
//!     assert_eq!(handler.val.get(), 0);
//!     dis.handle_message(&mut conn, sig);
//!     assert_eq!(handler.val.get(), 5);
//! }
//! ```

use rustc_serialize::Encodable;
use super::MethodRetVal;

pub type HandlerError = String;
/// Return value for signal handler functions
pub type SignalReturn = Result<(), HandlerError>;
/// Return value for method handler functions
pub type MethodReturn<T> = Result<Option<T>, HandlerError>;

// Empty tuple converts to EmptyReply
impl From<()> for MethodRetVal {
    fn from(_s: ()) -> Self {
        MethodRetVal::EmptyReply
    }
}

// Generate coversions from tuples of Encodables to MethodRetVal
macro_rules! peel {
    ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })
}

macro_rules! tuple {
    () => ();
    ( $($name:ident,)+ ) => (
        impl<$($name:Encodable),*> From<($($name,)*)> for MethodRetVal {
            #[allow(non_snake_case)]
            fn from(s: ($($name,)*)) -> Self {
                let ($(ref $name,)*) = s;
                MethodRetVal::Reply(vec![ $( $name.into() ),* ])
            }
        }
        peel! { $($name,)* }
    )
}

tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }

// The Option denotes whether or not to send a reply
impl<T: Into<MethodRetVal>> From<Option<T>> for MethodRetVal {
    fn from(o: Option<T>) -> Self {
        match o {
            Some(val) => val.into(),
            None => MethodRetVal::NoReply,
        }
    }
}

#[doc(hidden)]
#[macro_export]
macro_rules! dbus_ret {
    // Special handling for method calls
    { MethodCall, $val:expr } => ({
        let r: $crate::dispatch::MethodHandlerResult = $val.map(From::from).map_err(From::from);
        r
    });
    // Other message types (Signal) must return () and generate no reply
    { Signal, $val:expr } => (
        $val.map_err(|e| $crate::dispatch::DispatchError::OtherError(e))
    );
}

#[doc(hidden)]
#[macro_export]
macro_rules! dbus_arg {
    ( $argname:ident, $body:expr ) => ( {
                    use dbus_serialize::decoder::DBusDecoder;

                    try!(DBusDecoder::decode(
                        try!($body.next().ok_or($crate::dispatch::DispatchError::InvalidArguments))
                    ))
    } )
}

#[doc(hidden)]
#[macro_export]
macro_rules! dbus_call_handler {
    // No arguments. Don't unpack message body.
    ( $msgtype:ident, $sel:ident, $fname:ident, $sender:ident, $sig:ident, ( )) =>
        ( { dbus_ret!($msgtype, $sel.$fname($sender.0)) } );
    // Arguments
    ( $msgtype:ident, $sel:ident, $fname:ident, $sender:ident, $sig:ident, ( $($arg:ident : $ty:ty ),* )) => { {
                    let body = try!($sig.body.ok_or($crate::dispatch::DispatchError::InvalidArguments));
                    let mut i = body.into_iter();
                    dbus_ret!($msgtype, $sel.$fname( $sender.0, $( dbus_arg!($arg, i) ),* ))
    } };
}

#[doc(hidden)]
#[macro_export]
macro_rules! dbus_handler {
    ( $msgtype:ident, $handlertype:ident, $sel:ident, $handlers:ident, $fname:ident, ( $($arg:ident : $ty:ty ),* ) ) => (
        {
            // Push a tuple of (function name, boxed closure)
            $handlers.push((stringify!($fname),
                            Box::new(move |sender: $crate::dispatch::MessageSenderWrapper,
                                           _sig: $crate::dispatch::message_types::$msgtype| {
                                dbus_call_handler!($msgtype, $sel, $fname, sender, _sig, ( $($arg : $ty),* ) )
                            }) as $crate::dispatch::$handlertype ));
        }
    )
}

#[doc(hidden)]
#[macro_export]
macro_rules! dbus_handlers {
    ( $structname:ident, $msgtype:ident, $handlertype:ident, $getter:ident,
      $( $fname:ident, $body:block, $ret:ty, $_self:ident, $sender:ident, ( $($arg:ident : $ty:ty ),* ) ),*  ) => {
        impl $structname {
            /* Emit the original functions */
            $(
            #[allow(non_snake_case)]
            fn $fname(& $_self, $sender: &mut MessageSender $(,$arg : $ty)* ) -> $ret { $body }
            )*

            /* One function to return all handlers */
            pub fn $getter<'a>(&'a self) -> Vec<(&'static str, $crate::dispatch::$handlertype<'a>)> {
                let mut handlers = Vec::new();

                /* Code to generate each handler */
                $( dbus_handler!($msgtype, $handlertype, self, handlers, $fname, ( $($arg : $ty),* ) ); )*

                handlers
            }
        }
    };
}

/// Implements signal handlers from native Rust functions.
///
/// See the [module level documentation](dispatch/wrapper/index.html) for examples.
#[macro_export]
macro_rules! dbus_signal_impl {
    ( impl $structname:ident {
          $( fn $fname:ident(& $_self:ident, $sender:ident: &mut MessageSender $(,$arg:ident : $ty:ty),* ) ->
                SignalReturn $body:block )*
      } ) => { dbus_handlers!($structname, Signal, SignalHandler, get_signal_handlers,
               $( $fname, $body, SignalReturn, $_self, $sender, ( $($arg : $ty),* ) ),* ); };
}

#[macro_export]
/// Implements method call handlers from native Rust functions.
///
/// See the [module level documentation](dispatch/wrapper/index.html) for examples.
macro_rules! dbus_method_impl {
    ( impl $structname:ident {
          $( fn $fname:ident(& $_self:ident, $sender:ident: &mut MessageSender $(,$arg:ident : $ty:ty),* ) ->
                MethodReturn<$( $rok:ty ),*> $body:block )*
      } ) => { dbus_handlers!($structname, MethodCall, MethodHandler, get_method_handlers,
               $( $fname, $body, MethodReturn<$( $rok ),*>, $_self, $sender, ( $($arg : $ty),* ) ),* ); };
}

#[cfg(test)]
mod test {
    use dbus_serialize::types::Value;
    use ::connection::MessageSender;
    use ::dispatch::{MethodRetVal, message_types};
    use ::dispatch::wrapper::{MethodReturn, SignalReturn};

    struct TestHandler;

    dbus_signal_impl! {
        impl TestHandler {
            fn handler1(&self, _sender: &mut MessageSender) -> SignalReturn {
                Ok(())
            }
            fn handler2(&self, _sender: &mut MessageSender, _foo: String) -> SignalReturn {
                Ok(())
            }
        }
    }

    dbus_method_impl! {
        impl TestHandler {
            fn method1(&self, _sender: &mut MessageSender) -> MethodReturn<(u32, f32)> {
                Ok(Some((1, 2 as f32)))
            }
            fn method2(&self, _sender: &mut MessageSender, _foo: String) -> MethodReturn<()> {
                Ok(None)
            }
        }
    }

    #[test]
    fn test_sig_handler() {
        use ::connection::Connection;
        use ::dispatch::MessageSenderWrapper;
        use ::message;

        let mut conn = Connection::connect_system().unwrap();
        let mut msg = message::create_signal("path", "interface", "method");
        let sig = message_types::decode_message(&mut msg).unwrap();
        let o = TestHandler;
        if let message_types::MessageType::Signal(sig) = sig {
            let mut handlers = o.get_signal_handlers();
            handlers.pop();
            handlers.pop().unwrap().1(MessageSenderWrapper(&mut conn), sig).unwrap();
        } else { panic!() };

        let mut msg = message::create_method_call("dest", "path", "interface", "method");
        let mth = message_types::decode_message(&mut msg).unwrap();
        if let message_types::MessageType::Method(mth) = mth {
            let mut handlers = o.get_method_handlers();
            handlers.pop();
            let ret = handlers.pop().unwrap().1(MessageSenderWrapper(&mut conn), mth).unwrap();
            assert_eq!(ret, MethodRetVal::Reply(vec![Value::from(1 as u32), Value::from(2 as f32)]));
        } else { panic!() };
    }
}
